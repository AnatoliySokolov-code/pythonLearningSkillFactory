# 14.1. Понятие функции в Python
# Функция в программировании представляет собой обособленный участок кода,
# который можно вызывать несколько раз, обратившись к нему по имени,
# которым он был назван. При вызове происходит выполнение команд тела функции
# (команд, находящихся внутри функции).
# Функция — это блок кода, который начинается с ключевого слова def,
# затем следует название функции, затем скобки, в которых указываются аргументы
# функции, и двоеточие в конце. Со следующей строки начинается тело функции.
# Это именно тот участок, который будет выполняться при вызове функции.
# def name_func():
#     # начало тела функции
#     ...
#     # конец тела функции
# Тело функции должно находится на один отступ правее
# (на втором уровне вложенности), чем ключевое слово def c названием
# объявляемой функции. Так интерпретатор поймет, где заканчивается
# объявление функции и продолжается основная программа.
# Зачем нужны функции?
# Разберемся, для чего используются функции:
#
# Cтруктурирование кода.
# Выполнение одной задачи несколько раз.
# Выполнение одной задачи с различными входными данными.
# Во-первых, функции позволяют сделать код более читабельным.
# Увидеть одну строчку кода и по названию понять общую идею куда проще,
# чем разбираться с исходным кодом самого алгоритма. Поэтому ещё одним
# немаловажным фактором является то, как вы назовете вашу функцию.
# Чем более точно и ёмко вы назовете вашу функцию, тем проще будет вам самим
# и другим разработчикам понять, для чего предназначалась данная функция.
# Старайтесь избегать различных названий foo, bar, baz функций,
# название которых состоит из одной буквы. Пожалейте время и нервы тех,
# кому придется читать ваш код (а ведь это можете быть вы сами).
#
# В нашем случае мы можем сделать отдельную функцию подсчета частоты символов
# текста. Назвать её соответствующим образом char_frequency,
# а дальше внутри программы обращаться к нашей функции и по названию
# сразу понять, что происходит в данной части программы.
# объявили функцию для подсчета количества символов в тексте
def char_frequency():
   text = """
   У лукоморья дуб зелёный;
   Златая цепь на дубе том:
   И днём и ночью кот учёный
   Всё ходит по цепи кругом;
   Идёт направо -- песнь заводит,
   Налево -- сказку говорит.
   Там чудеса: там леший бродит,
   Русалка на ветвях сидит;
   Там на неведомых дорожках
   Следы невиданных зверей;
   Избушка там на курьих ножках
   Стоит без окон, без дверей;
   Там лес и дол видений полны;
   Там о заре прихлынут волны
   На брег песчаный и пустой,
   И тридцать витязей прекрасных
   Чредой из вод выходят ясных,
   И с ними дядька их морской;
   Там королевич мимоходом
   Пленяет грозного царя;
   Там в облаках перед народом
   Через леса, через моря
   Колдун несёт богатыря;
   В темнице там царевна тужит,
   А бурый волк ей верно служит;
   Там ступа с Бабою Ягой
   Идёт, бредёт сама собой,
   Там царь Кащей над златом чахнет;
   Там русский дух... там Русью пахнет!
   И там я был, и мёд я пил;
   У моря видел дуб зелёный;
   Под ним сидел, и кот учёный
   Свои мне сказки говорил.
   """

   text = text.lower()
   text = text.replace(" ", "")
   text = text.replace("\n", "")

   count = {}  # для подсчета символов и их количества
   for char in text:
       if char in count:  # если символ уже встречался, то увеличиваем его количество на 1
           count[char] += 1
       else:
           count[char] = 1

   for char, cnt in count.items():
       print(f"Символ {char} встречается {cnt} раз")

# ...

# вызвали функцию в любом месте программы
char_frequency()
# Вызов функции происходит путем указания названия функции и круглых скобок
# после него. Так интерпретатор понимает, что нужно выполнить указанную функцию.
# Если вы просто объявили функцию с помощью ключевого слова def,
# но не вызвали её, то никакого эффекта не будет.
# Это как лексикографический словарь, само определение слова там имеется,
# но чтобы оно давало какой-то эффект, оно должно применяться в тексте,
# разговоре и т. п.
# На самом деле функциями мы уже пользовались, только теми,
# которые были написаны другими программистами.
# Например функция print. Опять же, она всегда существует в программе,
# но чтобы она проявила свой эффект, её нужно вызвать.

# Но если бы функции позволяли только повторять какой-то участок кода,
# то чем бы это отличалось от обычного цикла, спросите вы?
# Функции ценны тем, что они могут менять своё поведение при разных
# входных данных без вмешательства в исходный код самой функции.
# Функция становится для нас как «чёрный ящик».
# Мы можем только передавать нашей функции какие-то данные и получать результат
# её выполнения вне зависимости от того, что творится в основной программе.
# То, что будет происходить внутри, нас не интересует,
# нам важен только результат.
# Не очень хорошо, что наша функция char_frequency умеет работать
# только с одним текстом. Нужно срочно исправлять ситуацию и делать её
# универсальной. Тогда объявление функции будет выглядеть по-другому:
# объявили функцию для подсчета количества символов в неком абстрактном тексте
def char_frequency(text):
   text = text.lower()
   text = text.replace(" ", "")
   text = text.replace("\n", "")

   count = {}  # для подсчета символов и их количества
   for char in text:
       if char in count:  # если символ уже встречался, то увеличиваем его количество на 1
           count[char] += 1
       else:
           count[char] = 1

   for char, cnt in count.items():
       print(f"Символ {char} встречается {cnt} раз")
# Отличие в том, что функция char_frequency принимает переменную text,
# которая ещё называется аргументом функции. И дальше внутри себя она работает
# с переменной text, не завися от её содержимого.
# Аргументы функций
# Входные данные, которые передаются нашей функции,
# называются аргументы функции.
# Функция может принимать неограниченное количество аргументов.
# Функция обязана принимать то количество аргументов,
# которое было объявлено при создании функции.
# Если передать отличное количество аргументов, то функция выдаст ошибку.
# Рассмотрим на примере.
#
# Давайте создадим функцию, которая будет возводить любое число в степень 2.
# функция, которая возводит любое число в квадрат
def pow_func(base):
   print(base ** 2)

pow_func(3)  # 9
pow_func(5)  # 25
# Если попытаться вызвать эту функцию без передачи ей аргументов,
# то вы получите следующую ошибку:
pow_func()
# TypeError: pow_func() missing 1 required positional argument: 'base'
# Означает она, что вы пропустили один обязательный аргумент.
# Давайте разбираться, что такое обязательные и необязательные аргументы.
#
# При вызове функции она должна получить значения всех указанных аргументов
# при её объявлении. Либо эти аргументы будут указаны при вызове,
# и тогда они являются обязательными. Либо вы можете указать значение
# аргумента, присвоив ему значение по умолчанию.
#
# Вернемся в примеру с возведением в степень.
# Пусть наша функция теперь возводит число в любую степень,
# но по умолчанию возводит в степень 2.
# Тогда её объявление будет выглядеть следующим образом:
# функция, которая возводит любое число в степень n
def pow_func(base, n=2):
   print(base ** n)

pow_func(3)  # 9
pow_func(5, 3)  # 125
# В данном примере мы возводим число 3 в степень 2, которая указана
# по умолчанию. В данном случае мы не получаем ошибку,
# хотя указали всего один аргумент. Значение второго аргумента
# уже известно функции, поэтому если вы не укажете ей его,
# то она возьмет его по умолчанию.
# Но если вы захотите переопределить значение по умолчанию,
# то тоже не получите никакой ошибки.
# Как в случае возведения числа 5 в степень 3.
# Функции умеют не только принимать аргументы, необходимые для их выполнения, но и возвращать значения.
#
# Делается это с помощью ключевого слова return.
# Наша функция pow_func не имеет внутри себя ключевого слова return,
# значит она ничего не возвращает? На самом деле это не так.
# Давайте попробуем распечатать результат выполнения нашей функции.
def pow_func(base, n=2):
   print(base ** n)

print(pow_func(3))
# 9
# None
# Видим, что помимо результата вычисления вывелось ещё значение None.
# Дело в том, что функции в Python всегда что-то возвращают, и если вы этого
# не указали, то автоматически интерпретатор подставит за вас строку return
# None в конец вашей функции. То есть её код в явном виде будет выглядеть
# следующим образом:
def pow_func(base, n=2):
   print(base ** n)
   return None

print(pow_func(3))
# 9
# None
# Тогда становится ясным, откуда берется None при распечатывании результата.
# Но вы можете самостоятельно указать, что должна возвращать ваша функция.
# Опять вернемся к примеру с возведением в степень.
# Сделаем так, чтобы наша функция возвращала результат вычисления:
def pow_func(base, n=2):
    inside_result = base ** n
    return inside_result

print(pow_func(3))
# 9
# Видим, что None пропало, и функция возвращает только результат
# вычисления, который содержится в переменной inside_result.
# Мы даже можем присвоить этот результат некоторой переменной
# и использовать это значение вне тела функции.
outside_result = pow_func(3)
print(outside_result)
# 9