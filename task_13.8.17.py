# zip()
# Рассмотрим еще одну полезную «фичу», которая упрощает работу со списками
# в циклах (а значит и во вложенных генераторах).
# Допустим, у нас есть два списка одинакового размера:
L = [i for i in range(10)]
# 0 1 2 3 4 5 6 7 8 9
M = [i for i in range(10,0,-1)]
# 10 9 8 7 6 5 4 3 2 1
# И нам необходимо создать новый список, который будет состоять из произведений
# соответствующих элементов друг на друга.
# он должен выглядеть так
# 0 9 16 21 24 25 24 21 16 9
# Мы знаем, что элементов в списке десять, поэтому можем пробежаться в цикле
# по индексам от 0 до 10:
N = [ ]
for i in range(10):
    N.append(L[i] * M[i])
# Такой код является корректным, но не «питоновским». Мы знаем, что циклом for можно итерировать сразу списки.
#
# Например:
for a in L:
    # какой-то код
# Но хотелось бы сделать так же, только сразу по двум спискам.
# В Python существует функция zip(), которая позволяет объединить два списка
# в новый список кортежей, каждый из которых будет содержать по одному элементу
# из каждого списка.
    for a in zip(L, M):
        print(a)
    # (0, 10)
    # (1, 9)
    # (2, 8)
    # (3, 7)
    # (4, 6)
    # (5, 5)
    # (6, 4)
    # (7, 3)
    # (8, 2)
    # (9, 1)
# Код можно сделать еще более приятным:
for a, b in zip(L,M):
    print('a =', a, 'b =', b)
#a = 0 b = 10
#a = 1 b = 9
#a = 2 b = 8
#a = 3 b = 7
#a = 4 b = 6
#a = 5 b = 5
#a = 6 b = 4
#a = 7 b = 3
#a = 8 b = 2
#a = 9 b = 1
# Сначала мы склеили два списка поэлементно, а потом на каждой итерации делали развертку кортежей на две переменные — a и b, которые использовали в теле самого цикла.
#
# Аналогично можно использовать функцию zip() и внутри генераторов списков.
#
# Задание 13.8.17
# Задание на самопроверку.
#
# Используя функцию zip() внутри генераторов списков,
# вычислите поэлементные произведения списков L и M.
N = [a*b for a,b in zip(L,M)]