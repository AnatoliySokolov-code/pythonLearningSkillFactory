# Представим, что на вход нашей программы подается число.
# А мы хотим проверить, является ли оно целым, находится ли в определенном
# промежутке (например от 100 до 999 включительно),
# да еще и делится ли на 2 и 3 одновременно. Очень много условий.
# И такое случается в реальных проектах.
#
# Решение в лоб — использовать вложенные условные операторы.
# Один if внутри другого if и так далее. Наверняка есть способ сделать
# это быстрее и эффективнее, но для начала попробуем написать решение
# в таком варианте, чтобы было с чем сравнить:
#
a = int(input())
# Напишите алгоритм, реализованный с помощью вложенных условных операторов,
# который проверяет заданные выше условия.
if type(a) == int:
    if 100 <= a <= 999:
        if a % 2 == 0:
            if a % 3 == 0:
                print("Число удовлетворяет условиям")
# Задание 13.8.10
# Напишите тот же алгоритм, но объедините все условия в одну строку
# , используя логические операторы и операторы сравнения:
if type(a) == int and 100 <= a <= 999 and a % 2 == 0 and a % 3 == 0:
    print("Число удовлетворяет условиям")
# Выглядит лучше по объему кода, но теперь выражение в условном
# операторе выглядит громоздко.
# Можно задаться вопросом: «А получится ли упростить это выражение?».
# Хотя бы по той причине, что все условия «состыкуются» с помощью логического И.
# И ответ — да, можно. В Python есть функция all([ ]),
# которая возвращает True, если все условия, переданные в аргумент
# функции в виде списка, являются истинными.
if all([type(a) == int,
        100 <= a <= 999,
        a % 2 == 0,
        a % 3 == 0]):
    print("Число удовлетворяет условиям")
# Такой подход является достаточно лаконичным
# и более эффективным, он более «питоновский».