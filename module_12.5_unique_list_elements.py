# Уникальные элементы списка
# Представим, что у нас есть список номеров и абонентов мобильного оператора,
# которым принадлежат эти номера.
# Всегда найдутся люди, на которых зарегистрировано несколько номеров. В таком
# случае в списке номеров-абонентов данные клиентов будут повторяться. Однако,
# например, для анализа клиентской базы может понадобиться выделить из общего
# списка только уникальные данные (скажем, уникальные фамилии).
#
# Можно подойти к этой задаче с помощью циклов, пробегая по каждому элементу
# исходного списка и добавляя в новый только уникальные элементы. Уже звучит
# так, что для, казалось бы, такой простой операции нужно написать много кода.
# Не правда ли? Это правда. Руководствуясь философией Python — простое лучше,
# чем сложное, — хотелось бы иметь более простой способ это сделать. И он есть!
#
# Для решения практических задач такого рода в Python есть ещё один изменяемый
# тип данных, который мы упоминали, но подробно не разбирали — множества (set).
#
# Множество — это неупорядоченный набор уникальных элементов. Иными словами, во множествах не могут повторяться элементы, а хранятся они в памяти компьютера в произвольном порядке.
#
# Создать множество можно несколькими способами:
a = {'a', 'b', 'c', 'd'} # используя синтаксис { }
# Или множество можно создать из списка с помощью приведения типов:
L = [1,1,2,3,2]
b = set(L)
print(b)
# {1,2,3}
# В начале мы имели список из 5 элементов, два из которых встречались дважды.
# «Обернув» исходный список в множество, мы получили только уникальные элементы!
# И не потребовалось писать много строк кода, чтобы это сделать.
# Осталось только множество вернуть
# обратно в списковое представление, опять же используя явное приведение типов.
b_list = list(b)
print(b_list)
# [1,2,3]
# А для краткости все эти операции можно записать в одну строку,
# ведь в Python естественным образом заложена лаконичность кода.
c = list(set(L))
print(c)
# [1,2,3]
# Множества в Python аналогичны математическим множествам,
# поэтому для них существует несколько собственных операций.
# Чтобы не ходить далеко за примером, вернёмся к базе абонентов мобильного оператора. Пусть у нас есть множество абонентов (для простоты — фамилии) и множество должников,
# а мы хотим получить множество абонентов, не имеющих долгов.
abons = {"Иванов", "Петров", "Васильев", "Антонов"}
debtors = {"Петров", "Антонов"}
non_debtors = abons.difference(debtors)
print(non_debtors)
# {'Васильев', 'Иванов'}